{
  "topic_id": 19,
  "topic_name": "Generics",
  "points": [
    {
      "id": 1,
      "point": "Generics",
      "sub_points": null,
      "snippet_codes": [
        " // Generics class\n class GenericClass<T : Serializable, U, V> { ... }\n\n // Generics interface\n interface GenericInterface<T, U> {\n     fun produce(): T\n     fun consume(value: U)\n }",
        " // Generics function\n fun <T, U, V> genericFunction(t: T, u: U, v: V): V { ... }"
      ]
    },
    {
      "id": 2,
      "point": "Generic types are only available at compile time.",
      "sub_points": null,
      "snippet_codes": null
    },
    {
      "id": 3,
      "point": "There is no general way to check whether an instance of a generic type was created with certain type arguments at runtime.",
      "sub_points": null,
      "snippet_codes": null
    },
    {
      "id": 4,
      "point": "Generic types in Java are invariant, meaning List<String> is not a subclass of List<Object> But not so in Kotlin.",
      "sub_points": null,
      "snippet_codes": [
        " // In kotlin\n val a: List<String> = listOf()\n val b: List<Any> = a"
      ]
    },
    {
      "id": 5,
      "point": "In Kotlin, we can use the `in` and `out` keywords to define the variance of a type parameter.",
      "sub_points": null,
      "snippet_codes": null
    },
    {
      "id": 6,
      "point": "covariant type parameter (class C is covariant in the parameter T or T parameter is covariant).",
      "sub_points": [
        "The `out` modifier is called a variance annotation.",
        "We can annotate the type parameter of generic class by 'out' modifier. to make sure that it is only returned (produced) from members of that, and never consumed.",
        "`out T` (in kotlin) ~ `? extends T` (in java).",
        "In a class, when a type is marked with \"out\", that type should only be used as a function output."
      ],
      "snippet_codes": [
        " interface CovariantGenerics<out T> {\n\n     fun produce(): T\n }",
        " class ProduceNumber() : CovariantGenerics<Number> {\n     override fun produce(): Number {\n         val num: Number = 1\n\n         return num\n     }\n }",
        " class ProduceInt() : CovariantGenerics<Int> {\n     override fun produce(): Int {\n         val num = 1\n         println(\"ProduceInt --> ${num::class.java.name}\")\n\n         return num\n     }\n }",
        " val produceInt = ProduceInt()\n val produceNumber: CovariantGenerics<Number> = produceInt\n\n produceNumber.produce()::class.java.name // Returned value is Int"
      ]
    },
    {
      "id": 7,
      "point": "contravariant type parameter (class C is contravariant in the parameter T or T parameter is contravariant).",
      "sub_points": [
        "The `in` modifier is called a variance annotation.",
        "It makes a type parameter contravariant, meaning it can only be consumed and never produced.",
        "`in T` (in kotlin) ~ `? super T` (in java).",
        "In a class, when a type is marked with `in`, that type should only be used as an input parameter to a function."
      ],
      "snippet_codes": [
        " interface ContravariantGenerics<in T> {\n\n     fun consume(value: T)\n }",
        " class ConsumeNumber : ContravariantGenerics<Number> {\n     override fun consume(value: Number) {\n         println(\"ConsumeNumber --> ${value::class.java.name}\")\n         value.toByte()\n     }\n }",
        " class ConsumeInt : ContravariantGenerics<Int> {\n     override fun consume(value: Int) {\n         println(\"ConsumeInt --> ${value::class.java.name}\")\n         value.toByte()\n     }\n }",
        " val consumeNumber = ConsumeNumber()\n val consumeInt: ContravariantGenerics<Int> = consumeNumber\n consumeInt.consume(1)\n // print \"ConsumeNumber --> java.lang.Integer\""
      ]
    },
    {
      "id": 8,
      "point": "We can use both covariant and contravariant type parameter in a class or interface.",
      "sub_points": null,
      "snippet_codes": [
        " interface GenericInterface<out T, in V> {\n\n     fun produce(): T\n     fun consume(value: V)\n }"
      ]
    },
    {
      "id": 9,
      "point": "definitely non-nullable",
      "sub_points": [
        "The most common use case for declaring definitely non-nullable types is when you want to override a Java method that contains @NotNull as an argument (`T & Any`)."
      ],
      "snippet_codes": [
        " fun consume(value: U & Any) { ... }"
      ]
    },
    {
      "id": 10,
      "point": "The underscore operator `_` can be used for type arguments.",
      "sub_points": null,
      "snippet_codes": null
    },
    {
      "id": 11,
      "point": "Use underscore operator to automatically infer a type of the argument when other types are explicitly specified.",
      "sub_points": null,
      "snippet_codes": null
    },
    {
      "id": 12,
      "point": "star projection `*` is a way to work with generic types when you don't know or don't need to specify the exact type parameter.",
      "sub_points": null,
      "snippet_codes": [
        " val list: MutableList<*> = mutableListOf(1, \"\", false, Class())\n list.add(1)"
      ]
    },
    {
      "id": 13,
      "point": "When we want to constraint type params in generic function we can use `where` keyword.",
      "sub_points": [
        "When we use `where` for a parameter, that parameter must be of the same type or subclasses."
      ],
      "snippet_codes": [
        " fun <T, U, V> genericFunction(t: T, u: U, v: V): V\n   where T: AnyType, U:AnyType { ... }"
      ]
    }
  ]
}